#!/usr/bin/env python3
#
# This script converts standard web content files (html, css, etc) into a C++ language
# header file that is included in the program body.  The files are compressed and use
# PROGMEM keyword to store in Flash to save RAM.
# Requires: gzip, xxd and sed.
#
# Copyright (c) 2023 David Kerr, https://github.com/dkerr64
#
import os
import subprocess
import shutil
import zlib
import base64


sourcepath = "src/www"
targetpath = sourcepath + "/build"

filenames = next(os.walk(sourcepath), (None, None, []))[2]
print("Compressing and converting files from " + sourcepath + " into " + targetpath)

# Start by deleting the target directory, then creating empty one.
try:
    shutil.rmtree(targetpath)
except FileNotFoundError:
    pass
os.mkdir(targetpath)

# calculate a CRC32 for each file and base64 encode it, this will change if the
# file contents are changed.  We use this to control browser caching.
file_crc = {}
sed_param = ""
for file in filenames:
    # skip hidden files
    if file[0] == ".":
        continue

    with open(sourcepath + "/" + file, "rb") as f:
        # read contents of the file
        data = f.read()
        crc32 = (
            base64.urlsafe_b64encode(zlib.crc32(data).to_bytes(4, byteorder="big"))
            .decode()
            .replace("=", "")
        )
        f.close()
        file_crc[file] = crc32
        # Build a SED search/replace string that will replace placeholder version with actual version CRC
        sed_param = (
            sed_param + "-e 's/" + file + "?v=CRC-32/" + file + "?v=" + crc32 + "/g' "
        )
        print("CRC: " + crc32 + " (" + file + ")")

# Open webcontent file and write warning header...
wf = open(targetpath + "/webcontent.h", "w")
wf.write("/**************************************\n")
wf.write(" * Autogenerated DO NOT EDIT\n")
wf.write(" **************************************/\n")
wf.write("#include <unordered_map>\n")
wf.write("#include <string>\n")
wf.flush()

varnames = []
# now loop through each file...
for file in filenames:
    # skip hidden files
    if file[0] == ".":
        continue

    t = file.rpartition(".")[-1]
    gzfile = targetpath + "/" + file + ".gz"
    varnames.append(
        (
            "/" + file,
            gzfile.replace(".", "_").replace("/", "_").replace("-", "_"),
            file_crc[file],
        )
    )
    f = open(gzfile, "w")
    if (t == "html") or (t == "htm") or (t == "js"):
        # run the SED command on files that may fetch sub-resources with CRC versioning.
        cmd = "sed " + sed_param + sourcepath + "/" + file + " | gzip -c "
        subprocess.run([cmd], stdout=f, shell=True, text=True)
    else:
        subprocess.run(["gzip", "-c", sourcepath + "/" + file], stdout=f)
    f.close()
    subprocess.run(["xxd", "-i", gzfile], stdout=wf)

wf.flush()

# Add possible MIME types to the file...
wf.write(
    """
const char type_svg[]  = "image/svg+xml";
const char type_bmp[]  = "image/bmp";
const char type_gif[]  = "image/gif";
const char type_jpeg[] = "image/jpeg";
const char type_jpg[]  = "image/jpeg";
const char type_png[]  = "image/png";
const char type_tiff[] = "image/tiff";
const char type_tif[]  = "image/tiff";
const char type_txt[]  = "text/plain";
const char type_htm[]  = "text/html";
const char type_html[] = "text/html";
const char type_css[]  = "text/css";
const char type_js[]   = "text/javascript";
const char type_mjs[]  = "text/javascript";
const char type_json[] = "application/json";

"""
)

# Use an unordered_map so we can lookup the data, length and type based on filename...
wf.write(
    "const std::unordered_map<std::string, std::tuple<unsigned char *, unsigned int, const char *, std::string>> webcontent = {"
)
n = 0
for file, var, crc32 in varnames:
    t = file.rpartition(".")[-1]
    # Need comma at end of every line except last one...
    if n > 0:
        wf.write(",")
    wf.write(
        '\n  { "'
        + file
        + '", {'
        + var
        + ", "
        + var
        + "_len, type_"
        + t
        + ', "'
        + crc32
        + '"'
        + "} }"
    )
    n = n + 1

# All done, close the file...
wf.write("\n};\n")
wf.close()

# Add the PROGMEM keyword to tell system to leave contents in Flash and not load into RAM...
subprocess.run(
    ["sed -i -e 's/_gz\[\]/_gz\[\] PROGMEM/g' " + targetpath + "/webcontent.h"],
    shell=True,
    text=True,
)
# convert all unsigned to const unsigned...
subprocess.run(
    ["sed -i -e 's/unsigned/const unsigned/g' " + targetpath + "/webcontent.h"],
    shell=True,
    text=True,
)
print("processed " + str(len(varnames)) + " files")
