#!/usr/bin/env python3
#
# This script converts standard web content files (html, css, etc) into a C++ language
# header file that is included in the program body.  The files are compressed and use
# PROGMEM keyword to store in Flash to save RAM.
# Requires: gzip, xxd and sed.
# 
# Copyright (c) 2023 David Kerr, https://github.com/dkerr64
#
import os
import subprocess
import shutil

sourcepath = "src/www"
targetpath = sourcepath + "/build"

filenames = next(os.walk(sourcepath), (None, None, []))[2]
print("Compressing and converting files from " + sourcepath + " into " + targetpath)
print(filenames)

# Start by deleting the target directory, then creating empty one.
try:
    shutil.rmtree(targetpath)
except FileNotFoundError:
    pass
os.mkdir(targetpath)

# Open webcontent file and write warning header...
wf = open(targetpath + "/webcontent.h", "w")
wf.write("/**************************************\n")
wf.write(" * Autogenerated DO NOT EDIT\n")
wf.write(" **************************************/\n")
wf.write("#include \"Arduino.h\"\n")
wf.write("#include <string>\n")
wf.flush()

varnames = []
# now loop through each file...
for file in filenames:
    gzfile = targetpath + "/" + file + ".gz"
    varnames.append(("/" + file, gzfile.replace(".", "_").replace("/", "_")))
    f = open(gzfile, "w")
    subprocess.run(["gzip", "-c", sourcepath + "/" + file], stdout=f)
    f.close()
    subprocess.run(["xxd", "-i", gzfile], stdout=wf)

wf.flush()

# Add possible MIME types to the file...
wf.write(
    """
char type_svg[]  = "image/svg+xml";
char type_bmp[]  = "image/bmp";
char type_gif[]  = "image/gif";
char type_jpeg[] = "image/jpeg";
char type_jpg[]  = "image/jpeg";
char type_png[]  = "image/png";
char type_tiff[] = "image/tiff";
char type_tif[]  = "image/tiff";
char type_txt[]  = "text/plain";
char type_htm[]  = "text/html";
char type_html[] = "text/html";
char type_css[]  = "text/css";
char type_js[]   = "text/javascript";
char type_mjs[]  = "text/javascript";
char type_json[] = "application/json";

"""
)

# Use an unordered_map so we can lookup the data, length and type based on filename...
wf.write(
    "std::unordered_map<std::string, std::tuple<unsigned char *, unsigned int, char *>> webcontent = {"
)
n = 0
for file, var in varnames:
    t = file.rpartition(".")[-1]
    # Need comma at end of every line except last one...
    if n > 0:
        wf.write(",")
    wf.write('\n  { "' + file + '", {' + var + ", " + var + "_len, type_" + t + "} }")
    n = n + 1

# All done, close the file...
wf.write("\n};\n")
wf.close()

# Add the PROGMEM keyword to tell system to leave contents in Flash and not load into RAM...
subprocess.run(
    ["sed", "-i", "s/_gz\[\]/_gz\[\] PROGMEM/g", targetpath + "/webcontent.h"]
)

print("processed " + str(len(varnames)) + " files")
