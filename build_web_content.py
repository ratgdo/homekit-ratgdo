#!/usr/bin/env python3
#
# This script converts standard web content files (html, css, etc) into a C++ language
# header file that is included in the program body.  The files are compressed and use
# PROGMEM keyword to store in Flash to save RAM.
# Requires: gzip, xxd and sed.
# 
# Copyright (c) 2023 David Kerr, https://github.com/dkerr64
#
import os
import subprocess
import shutil
import hashlib

sourcepath = "src/www"
targetpath = sourcepath + "/build"

filenames = next(os.walk(sourcepath), (None, None, []))[2]
print("Compressing and converting files from " + sourcepath + " into " + targetpath)
print(filenames)

# Start by deleting the target directory, then creating empty one.
try:
    shutil.rmtree(targetpath)
except FileNotFoundError:
    pass
os.mkdir(targetpath)

# Open webcontent file and write warning header...
wf = open(targetpath + "/webcontent.h", "w")
wf.write("/**************************************\n")
wf.write(" * Autogenerated DO NOT EDIT\n")
wf.write(" **************************************/\n")
# wf.write("#include \"Arduino.h\"\n")
wf.write("#include <unordered_map>\n")
wf.write("#include <string>\n")
wf.flush()

varnames = []
# now loop through each file...
for file in filenames:
    # skip hidden files
    if file[0] == ".":
        continue

    with open(sourcepath + "/" + file, 'rb') as f:
        # read contents of the file
        data = f.read()
        # pipe contents of the file through
        md5 = hashlib.md5(data).hexdigest()
        f.close()

    gzfile = targetpath + "/" + file + ".gz"
    varnames.append(("/" + file, gzfile.replace(".", "_").replace("/", "_").replace("-", "_"), md5))
    f = open(gzfile, "w")
    subprocess.run(["gzip", "-c", sourcepath + "/" + file], stdout=f)
    f.close()
    subprocess.run(["xxd", "-i", gzfile], stdout=wf)

wf.flush()

# Add possible MIME types to the file...
wf.write(
    """
const char type_svg[]  = "image/svg+xml";
const char type_bmp[]  = "image/bmp";
const char type_gif[]  = "image/gif";
const char type_jpeg[] = "image/jpeg";
const char type_jpg[]  = "image/jpeg";
const char type_png[]  = "image/png";
const char type_tiff[] = "image/tiff";
const char type_tif[]  = "image/tiff";
const char type_txt[]  = "text/plain";
const char type_htm[]  = "text/html";
const char type_html[] = "text/html";
const char type_css[]  = "text/css";
const char type_js[]   = "text/javascript";
const char type_mjs[]  = "text/javascript";
const char type_json[] = "application/json";

"""
)

# Use an unordered_map so we can lookup the data, length and type based on filename...
wf.write(
    "const std::unordered_map<std::string, std::tuple<unsigned char *, unsigned int, const char *, std::string>> webcontent = {"
)
n = 0
for file, var, md5 in varnames:
    t = file.rpartition(".")[-1]
    # Need comma at end of every line except last one...
    if n > 0:
        wf.write(",")
    wf.write('\n  { "' + file + '", {' + var + ", " + var + "_len, type_" + t + ', "' + md5 + '"' + "} }")
    n = n + 1

# All done, close the file...
wf.write("\n};\n")
wf.close()

# Add the PROGMEM keyword to tell system to leave contents in Flash and not load into RAM...
subprocess.run(
    ["sed", "-ie", "s/_gz\[\]/_gz\[\] PROGMEM/g", targetpath + "/webcontent.h"]
)
# convert all undigned to const unsigned...
subprocess.run(
    ["sed", "-ie", "s/unsigned/const unsigned/g", targetpath + "/webcontent.h"]
)
print("processed " + str(len(varnames)) + " files")
